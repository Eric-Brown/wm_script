# Main WMS gen code class.
WMSGen = {
	# The DOM form we're using
	"form": 0,
	
	# Last selected mission type (for fillSubTypeList)
	"lastMissionType": 0,
	
	# Enable advanced mode
	"advanced": false,
	
	/**
	 * Handle initial page setup.
	 */
	"setup": function(form) {
		this.form = form;
		
		# Advanced mode is enabled if we have ?advanced in the URL params.
		if(this.advanced) {
			$('advancedMode').style.display = 'block';
			$('advancedModeOnlyStuff').style.display = 'block';
		}
		
		this.fillDungeonList();
		this.fillTypeList();
		this.fillSubTypeList();
		
		this.fillItemLists();
		this.fillMonsterLists();
		
		this.update();
	},
	
	/**
	 * Fills the dungeon list from sky_dungeon.js.
	 */
	"fillDungeonList": function() {
		var box = this.form.dungeonBox;
		box.style.display = 'none';
		
		var dungeons = WMSkyDungeon;
		if(this.advanced) {
			for(var key in dungeons) {
				if(dungeons.hasOwnProperty(key)) {
					addOptionToSelect(box, key, dungeons[key]);
				}
			}
		}
		else {
			for(var i = 0; i < WMSGenData.validDungeons.length; ++i) {
				var key = WMSGenData.validDungeons[i];
				addOptionToSelect(box, key, dungeons[key]);
			}
		}
		
		box.style.display = 'inline';
	},
	
	/**
	 * Returns the True monster ID for a given ID based on if the female box is checked.
	 *
	 * Both male-only and female-only mons are in the male range and do not allow females.
	 * Otherwise, females are simply +600 from the male one.
	 */
	"getTrueMonID": function(id, femaleChecked) {
		# First, make the id male to start with.
		id = id % 600;
		
		# Second, the special case. Nidoran doesn't follow the standard +600 convention.
		if(id == WMSGenData.NIDORAN_MALE || id == WMSGenData.NIDORAN_FEMALE) {
			if(femaleChecked) {
				return WMSGenData.NIDORAN_FEMALE;
			}
			else {
				return WMSGenData.NIDORAN_MALE;
			}
		}
		
		# Third, the actual check.
		var maleOnly = (WMSGenData.maleOnly.indexOf(id) != -1);
		var femaleOnly = (WMSGenData.femaleOnly.indexOf(id) != -1);
		
		if((maleOnly || femaleOnly) && femaleChecked) {
			console.info("Prevented %d from being marked as female.", id);
			return id;
		}
		else if(femaleChecked) {
			return id + 600;
		}
		else {
			return id;
		}
	},
	
	/**
	 * Fills various item lists from sky_item.js.
	 */
	"fillItemLists": function() {
		var box1 = this.form.targetItemBox, box2 = this.form.rewardItemBox;
		
		# Get Chrome to behave...
		box1.style.display = 'none';
		box2.style.display = 'none';
		var items = WMSkyItem;
		for(var key in items) {
			# For if we use something that extends Object.prototype...
			if(items.hasOwnProperty(key)) {
				addOptionToSelect(box1, key, items[key]);
				addOptionToSelect(box2, key, items[key]);
			}
		}
		box1.style.display = 'inline';
		box2.style.display = 'inline';
	},
	
	/**
	 * Fills various monster lists from sky_poke.js.
	 */
	"fillMonsterLists": function() {
		var box1 = this.form.clientBox, box2 = this.form.targetBox, box3 = this.form.target2Box;
		
		# Get Chrome to behave...
		# box3 is hidden by default.
		box1.style.display = 'none';
		box2.style.display = 'none';
		var poke = WMSkyPoke;
		if(this.advanced) {
			for(var key in poke) {
				if(poke.hasOwnProperty(key)) {
					addOptionToSelect(box1, key, poke[key]);
					addOptionToSelect(box2, key, poke[key]);
					addOptionToSelect(box3, key, poke[key]);
				}
			}
		}
		else {
			for(var i = 0; i < WMSGenData.validClients.length; ++i) {
				var monsterNum = WMSGenData.validClients[i];
				addOptionToSelect(box1, monsterNum, poke[monsterNum]);
				addOptionToSelect(box2, monsterNum, poke[monsterNum]);
				addOptionToSelect(box3, monsterNum, poke[monsterNum]);
			}
		}
		box1.style.display = 'inline';
		box2.style.display = 'inline';
	},
	
	/**
	 * Fills the missionType list.
	 */
	"fillTypeList": function() {
		# Get the box.
		var box = this.form.missionTypeBox;
		box.style.display = 'none';
		
		# Add types!
		var types = WMSGenData.missionTypes;
		for(var i = 0; i < types.length; ++i) {
			if(!types[i].advancedOnly || this.advanced) {
				addOptionToSelect(box, i, types[i].name);
			}
		}
		
		box.style.display = 'inline';
	},
	
	/**
	 * Fills the mission subType list based on the currently selected mission. Called multiple times.
	 * Also sets the display property on subType and other things.
	 */
	"fillSubTypeList": function() {
		# Get the currently selected type.
		var typeBox = this.form.missionTypeBox;
		var typeNum = 0;
		if(typeBox.options[typeBox.selectedIndex]) {
			typeNum = parseInt(typeBox.options[typeBox.selectedIndex].value, 10);
		}
		
		# Make sure that we don't reset the subtype box if the browser annoys us by sending the change multiple times.
		if(typeNum == this.lastMissionType) {
			return;
		}
		this.lastMissionType = typeNum;
		
		# Get the type data
		var typeData = WMSGenData.missionTypes[typeNum];
		if(typeData && typeData.subTypes) {
			# Empty the subTypeBox (called box from now on).
			var box = this.form.missionSubTypeBox;
			while(box.options.length) {
				box.remove(0);
			}
			
			# Add subTypes for the mission to the select box, unless they are advancedOnly.
			for(var i = 0; i < typeData.subTypes.length; ++i) {
				var subData = typeData.subTypes[i];
				if(!subData.advancedOnly) {
					addOptionToSelect(box, i, subData.name);
				}
			}
			$('subType').style.display = "inline";
		}
		else {
			$('subType').style.display = "none";
		}
	},
	
	/**
	 * Returns the value of the currently selected option in a given <select> box (combobox).
	 * @param DOMSelect|String Combobox or string with name for one
	 * @return String|boolean Value or boolean false
	 */
	"getComboBoxValue": function(box) {
		if(typeof box == "string") {
			box = this.form[box];
		}
		
		if(box && box.options[box.selectedIndex]) {
			return box.options[box.selectedIndex].value;
		}
		else {
			return false;
		}
	},
		
	/**
	 * Verifies if the input is valid.
	 * @param DOMForm Form to check
	 * @return array Array containing strings of error messages; empty = all good
	 */
	"verify": function() {
		var errors = [];
		
		var typeData = this.getTypeData();
		
		# If we don't use a forced client and have validClients, check them.
		if(!typeData.hasOwnProperty("forceClient")) {
			if(typeData.hasOwnProperty("validClients")) {
				var client = parseInt(this.form.clientBox, 10);
				var checkPassed = false;
				for(var i = 0; i < typeData.validClients.length; ++i) {
					if(client == typeData.validClients[i]) {
						checkPassed = True;
					}
				}
				
				# Build the error.
				if(!checkPassed) {
					var error = "Invalid client selected. You must use one of: ";
					for(var i = 0; i < typeData.validClients.length; ++i) {
						error += (i !== 0 ? ", " : "") + getMonName(typeData.validClients[i]);
					}
					errors[errors.length] = error;
				}
			}
		}
		
		# Check if we have a valid reward item (if we get a reward item).
		var rewardType = parseInt(this.getComboBoxValue("rewardTypeBox"), 10);
		if(!typeData.noReward && rewardType >= 1 && rewardType <= 4) {
			var rewardItem = parseInt(this.getComboBoxValue("rewardItemBox", 10));
			if(rewardItem == 0) {
				errors[errors.length] = "You must select a reward item!";
			}
		}

		# Check if we have a valid target item.
		if(typeData.useTargetItem) {
			var targetItem = parseInt(this.getComboBoxValue("targetItemBox", 10));
			for(var i = 0; i < WMSGenData.badTargetItems.length; ++i) {
				if(WMSGenData.badTargetItems[i] == targetItem) {
					errors[errors.length] = "The target item you selected is invalid (stackables are not allowed).";
				}
			}
		}
		
		return errors;
	},
	
	/**
	 * Returns typeData for the currently selected missionType/subType. typeData is an object with the following keys:
	 * @return object typeData
	 */
	"getTypeData": function() {
		# Mission type
		var typeNum = parseInt(this.getComboBoxValue("missionTypeBox"), 10);
		var typeData = WMSGenData.missionTypes[typeNum];
		if(!typeData) {
			return false;
		}
		
		# See if this mission has a subtype.
		if(typeData.subTypes) {
			# Get the currently selected subtype.
			var subTypeNum = parseInt(this.getComboBoxValue("missionSubTypeBox"), 10);
			var subTypeData = typeData.subTypes[subTypeNum];
			if(subTypeData) {
				# Create a soft copy of typeData. This allows us to copy subTypeData over typeData without screwing
				# things up in the future. This is generally a good thing.
				var tmp = {};
				var key;
				for(key in typeData) {
					if(typeData.hasOwnProperty(key)) {
						tmp[key] = typeData[key];
					}
				}
				typeData = tmp;
				
				# Copy subTypeData to typeData.
				for(key in subTypeData) {
					if(subTypeData.hasOwnProperty(key)) {
						typeData[key] = subTypeData[key];
					}
				}
			}
		}
		
		return typeData;
	},
	
	/**
	 * Shows or hides things when various items in the form are changed.
	 * @return void
	 */
	"update": function() {
		var typeData = this.getTypeData();
		
		# Crappy browser syndrome...
		if(!typeData) {
			return;
		}
		
		this.form.target2Box.disabled = !typeData.useTarget2;
		# HACK: show target2 container by id.
		$('target2').style.display = (typeData.useTarget2 ? 'block' : 'none');
		
		this.form.targetItemBox.disabled = !typeData.useTargetItem;

		var rewardType = parseInt(this.getComboBoxValue("rewardTypeBox"), 10);
		this.form.rewardTypeBox.disabled = typeData.noReward;
		this.form.rewardItemBox.disabled = typeData.noReward || (rewardType < 1 || rewardType > 4);
		
		this.form.clientBox.disabled = typeData.hasOwnProperty("forceClient");
		this.form.clientF.disabled = typeData.hasOwnProperty("forceClient");
		this.form.targetBox.disabled = typeData.hasOwnProperty("forceTarget");
		this.form.targetF.disabled = typeData.hasOwnProperty("forceTarget");
		
		if(typeData.clientIsTarget) {
			this.form.targetBox.disabled = True;
			this.form.targetF.disabled = True;
		}
	},
	
	/**
	 * Generates a code and returns it.
	 * @return String|boolean Prettified code or boolean false
	 */
	"generate": function() {
		# Get typeData.
		var typeData = this.getTypeData();
		
		# Build the base struct.
		var struct = {};
		
		struct.missionType = typeData.mainType;
		struct.missionSpecial = typeData.specialType;
		
		struct.nullBits = 0;
		struct.mailType = 4;
		struct.restriction = 0;
		struct.restrictionType = 0;
		struct.rewardType = parseInt(this.getComboBoxValue("rewardTypeBox"), 10);
		
		# Client
		if(typeData.hasOwnProperty("forceClient")) {
			struct.client = typeData.forceClient;
		}
		else {
			var client = parseInt(this.getComboBoxValue("clientBox"), 10);
			struct.client = this.getTrueMonID(client, this.form.clientF.checked);
		}
		
		# Target
		if(typeData.hasOwnProperty("forceTarget")) {
			struct.target = typeData.forceTarget;
		}
		else if(typeData.clientIsTarget) {
			struct.target = struct.client;
		}
		else {
			var client = parseInt(this.getComboBoxValue("targetBox"), 10);
			struct.target = this.getTrueMonID(client, this.form.targetF.checked);
		}
		
		# Target 2
		if(typeData.useTarget2) {
			# See if this works better.
			struct.target2 = struct.target;
		}
		else {
			# Defaults to zero, let's keep it that way.
			struct.target2 = 0;
		}
		
		# Reward - based on reward type
		if(typeData.noReward) {
			# If we don't use a reward for this mission type, set it to Cash + Apple.
			struct.rewardType = 1;
			struct.reward = 109;
		}
		else if(struct.rewardType >= 1 && struct.rewardType <= 4) {
			struct.reward = parseInt(this.getComboBoxValue("rewardItemBox"), 10);
		}
		else if(struct.rewardType == 5 || struct.rewardType == 6) {
			struct.reward = struct.client;
		}
		else {
			# The game seems to complain about not having a reward, so here's an Apple for you.
			struct.reward = 109;
		}
		
		# Target item - based on mission type
		if(typeData.useTargetItem) {
			struct.targetItem = parseInt(this.getComboBoxValue("targetItemBox"), 10);
		}
		else {
			# The game also seems to complain about not having a targetItem, so here's an Apple for you.
			struct.targetItem = 109;
		}
		
		# Dungeon/floor
		var dungeon = parseInt(this.getComboBoxValue("dungeonBox"), 10);
		struct.dungeon = dungeon || 1;
		var floor = parseInt(this.form.floor.value, 10);
		struct.floor = (floor >= 1 && floor <= 99) ? floor : 1;
		
		# Special floor
		if(this.form.specialFloor.value != "") {
			struct.specialFloor = parseInt(this.form.specialFloor.value, 10);
		}
		else if(typeData.hasOwnProperty("specialFloor")) {
			struct.specialFloor = typeData.specialFloor;
		}
		else if(typeData.hasOwnProperty("specialFloorFromList")) {
			# Check for list existance.
			var listName = typeData.specialFloorFromList;
			var list = WMSGenData.staticLists[listName];
			if(!list) {
				console.error("Static list %s not found.", listName);
			}
			var entry = Math.floor(Math.random() * (list.length - 1));
			console.info("Picked specialFloor entry %d, value: %d", entry, list[entry]);
			struct.specialFloor = list[entry];
		}
		else {
			struct.specialFloor = 0;
		}
		
		var decBitStream;
		
		# Do we have a flavor text override?
		if(this.form.flavorText.value != "") {
			# Use it.
			struct.flavorText = parseInt(this.form.flavorText.value, 10);
			decBitStream = WMSParser.structureToBits(struct);
		}
		else {
			# If advanced mode is on, don't add a random number (produce predictable codes).
			# Otherwise, pick a random number in between 300000-400000; this value isn't special in any way.
			struct.flavorText = 300000 + (this.advanced ? 0 : Math.floor(Math.random() * 100000));
			
			decBitStream = WMSParser.structureToBits(struct);
			var checksum = bitsToNum(decBitStream.substr(138));
			var resetByte = WMSParser.getResetByte(checksum);
			console.info("flavorText %d, checksum %d, reset %d", struct.flavorText, checksum, resetByte);
		}
		
		# Encrypt the code.
		var encBitStream = WMSParser.encryptBitStream(decBitStream);

		# Bitpack it.
		var bitpacked = WMSParser.bitsToBytes(encBitStream);

		# Scramble it.
		var byteSwap = this.form.useEUswap.checked ? WMSParser.byteSwapEU : WMSParser.byteSwap;
		var scrambled = WMSParser.scrambleString(bitpacked, byteSwap);
		
		# Prettify it.
		var prettified = prettyMailString(scrambled, 2, 7);
		
		console.info("enc: %o, packed: %o, scrambled: %o, prettified: %o", encBitStream, bitpacked, scrambled, prettified);
		
		return prettified;
	},
	
	/**
	 * Notifies the user of an error.
	 * @param String The error
	 * @FIXME Needs rewrite and a lot of things really
	 */
	"setError": function(text) {
		$('outputbox').value = text;
	}
};

/**
 * Adds an option to a select box.
 * This function is implemented in this way because IE doesn't accept "null" as a param to box.add().
 * @param DOMSelect Box to add stuff into
 * @param String Value of this option
 * @param String Text to add
 */
addOptionToSelect = function() {
	# This hack is required for Closure Compiler.
	# See http://code.google.com/closure/compiler/docs/limitations.html
	var isMSIE = eval("/*@cc_on 1 + @*/0");
	if(isMSIE) {
		return function(box, value, text) {
			var element = document.createElement('option');
			element.value = value.toString();
			element.text = text;
			
			box.add(element);
		};
	}
	else {
		return function(box, value, text) {
			var element = document.createElement('option');
			element.value = value.toString();
			element.text = text;
			
			box.add(element, null);
		};
	}
}();
